Google STEP 2017 / Week2 Homework

＊宿題2
ハッシュテーブルの代表的な欠点は
・空間計算量が大きくなってしまうこと
・衝突を回避するためにハッシュ関数をよく考えなければならないこと
である。特に２つ目は，データが多くなってくればくるほど衝突が起こりやすくなるわけで，完全に衝突を避けることは難しい。また，ハッシュの種類よりデータの数が大きくなった時に，そのまま放っておけば計算量は(全ハッシュ値にデータが均等に分布すると仮定したとしても)O(N)になってしまうが，ハッシュ関数を変えてハッシュの種類を増やすことも困難である(もとのハッシュテーブルを一から作り直さなければならなくなる)。
その点二分木では，計算量はO(logN)以下にならないかもしれないものの，データが多くなってきてもその構造を保つことができる。さらに，データの追加の際にアンバランスな木が生じたとしても回転によってALV木にすることができるため，計算量O(logN)の水準を保つことができる。

＊宿題3

＜最初に考えたこと＞(普通です)----------------------------------------------------------------------------
・キャッシュの配列の長さをNとし，a[0], a[1], a[2], a[3], ... , a[N-1]みたいな配列になっているとする。
・配列の要素1つ1つには＜URLから生成したハッシュ値, URL, Webページの内容＞が入っている。
・a[i]はa[i+1]より最終アクセス日時が新しい。
・例えば，
a[0]=サイトA
a[1]=サイトB
a[2]=サイトC
…
a[N-1]=サイトZ
としたとき，新しく訪ねたサイトαが配列aに含まれるかどうか，ハッシュ値を使って検索する。(aのN個の要素全てについて，ハッシュがサイトαのハッシュと一致するか調べる)。
 - サイトαがaに含まれるなら→サイトαがa[k]に格納されたサイトと対応したとすると，
	i<=kについて：a[i]=a[i-1]と定義し直す，a[0]=サイトα
	i>kについて：そのまま
 - サイトαがaに含まれないなら→
	全てのi<Nについてa[i]=a[i-1],a[0]=サイトα
となる。
・当然これだと，検索の過程でも，書き換える過程でも，計算量がO(N)なんですよね…
---------------------------------------------------------------------------------------------------

・ここで，ハッシュとリストについて調べてみると，
	リスト…ランダムアクセスはO(N)の時間がかかるが，データの追加・削除はO(1)でできる。
	ハッシュ…ランダムアクセスはO(1)でできるが，データの追加・削除はO(N)の時間がかかる。
　ということが分かったので，「リストとハッシュの良い点を組み合わせたらいけるんじゃないか」と思い，添付写真のような方法を考えました。

---------------------------------------------------------------------------------------------------

写真の方法で問題になってくるのは，「ハッシュテーブル11にサイトMのポインタとサイトYのポインタが両方残ってしまっていることかなと思います…
